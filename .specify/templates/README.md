# RiskInsure Spec Kit Templates

This directory contains templates customized for RiskInsure's event-driven, DDD-based architecture.

## Template Selection Guide

### For Feature Specifications

**Use `spec-template.md` (Full) when:**
- Creating a complex, multi-service feature
- Domain documentation doesn't exist yet for this area
- Need to capture extensive functional requirements
- Feature involves significant new domain concepts

**Use `spec-template-quick.md` (Lightweight) when:**
- Domain docs already exist
- You just need to capture the delta (new scenarios + messages)
- Feature is a straightforward addition to existing domain
- Time is limited and you want to get to code fast

**Recommendation**: Start with `spec-template-quick.md` for 80% of features. It's designed for "reference what exists, define what's new."

---

## Template Overview

### `spec-template.md` (Full)
Comprehensive specification including:
- Detailed user stories with priorities
- Full functional requirements list
- Extended edge case coverage
- Complete entity descriptions

**Authoring time**: 30–60 minutes for thorough specifications

---

### `spec-template-quick.md` (Lightweight) ⚡
Optimized for rapid authoring:
- Primary scenario + acceptance criteria (Given/When/Then)
- New message contracts (commands/events) with required metadata
- Data strategy (partition key, idempotency)
- Edge cases and failure modes
- References to existing domain docs

**Authoring time**: 10–20 minutes for most features

**Key sections**:
1. **Context (References)** - Links to existing docs
2. **What's New (The Delta)** - Only new behavior
3. **Message Contracts** - Commands/events with C# record examples
4. **Data Changes** - Persistence choice + partition/idempotency strategy
5. **Non-Goals** - Explicit scope boundaries

---

### `plan-template.md`
Implementation plan generated by `/speckit.plan`:
- RiskInsure stack enforced (.NET 10, NServiceBus 9.x)
- **Persistence choice gate**: Must decide Cosmos DB OR PostgreSQL
- Constitution compliance checklist (9 principles)
- Service structure (Domain → Infrastructure → Api → Endpoint.In)

---

### `tasks-template.md`
Task list generated by `/speckit.tasks`:
- Organized by user story (for independent implementation)
- RiskInsure layering: Domain-first, then Infrastructure, then API/Endpoint
- Foundation phase includes: message contracts, NServiceBus config, persistence setup

---

### `constitution-template.md`
Points to RiskInsure's existing constitution at `.specify/memory/constitution.md`. Read this first to understand non-negotiable principles.

---

### `checklist-template.md`
Quality/validation checklist generator (use `/speckit.checklist` after planning).

---

## Path Resolution Contract (Required)

All generated artifacts MUST use concrete, service-local paths before reporting success.

- Do not leave placeholders like `services/<domain>/`, `[###-feature-name]`, `/specs/###-...`, or token markers unresolved.
- Prefer explicit `-SpecPath` / `-ServicePath` inputs when running setup/check scripts from agent prompts.
- Paths must resolve under the selected bounded context service root (for example, `services/nsb.sales/`).
- Cross-context names are not interchangeable: never emit Billing-specific path/namespace terms in Sales artifacts (or vice versa).
- If placeholders remain after generation, treat it as incomplete output and regenerate/fix before continuing.

---

## RiskInsure Workflows

### Quick Feature (Recommended)

1. **Specify** (10–15 min): Use `spec-template-quick.md`
   - Fill in scenarios + acceptance criteria
   - Define new commands/events
   - Choose persistence (Cosmos/PostgreSQL)
   - Reference existing domain docs
   
2. **Plan** (10–15 min): Run `/speckit.plan <tech choices>`
   - AI generates implementation plan with constitution checks
   - Creates data model, contracts, quickstart guide
   
3. **Tasks** (5 min): Run `/speckit.tasks`
   - AI generates task list organized by user story
   - Tasks follow Domain → Infrastructure → API → Tests order
   
4. **Implement** (varies): Code following task order
   - Domain layer first (pure business logic)
   - Infrastructure (handlers, repositories)
   - Tests (xUnit + Playwright)
   
5. **Validate** (ongoing): Use constitution checklist
   - Handlers are thin and idempotent
   - Messages include required metadata
   - Test coverage meets thresholds

### Complex Feature (Full Process)

Same as Quick Feature, but use `spec-template.md` for more detailed requirements capture upfront.

---

## Key RiskInsure Patterns (Enforced by Templates)

### Message Metadata (Required)
All commands/events MUST include:
```csharp
Guid MessageId              // Unique identifier
DateTimeOffset OccurredUtc  // When it happened
string IdempotencyKey       // Deduplication key
```

### Persistence Choice (Required)
Every feature with data MUST choose:
- **Cosmos DB**: Single-partition strategy, partition key = processing unit
- **PostgreSQL**: Normalized schema with proper indexing

### Layering (Enforced)
- **Domain** (pure business logic) → NO infrastructure dependencies
- **Infrastructure** → Implements domain interfaces
- **Api/Endpoint** → Thin hosting layers

### Handler Pattern (Required)
```csharp
public async Task Handle(Command message, IMessageHandlerContext context)
{
    // 1. Check idempotency (existing state)
    var existing = await _repo.GetByIdAsync(message.EntityId);
    if (existing != null) return; // Already processed
    
    // 2. Delegate to domain service/manager
    var result = await _service.ProcessAsync(message);
    
    // 3. Publish events
    await context.Publish(new EntityProcessed(...));
    
    // 4. Log with correlation IDs
    _logger.LogInformation("Processed {EntityId} in {Context}", 
        message.EntityId, message.ProcessingUnitId);
}
```

---

## Constitution Quick Reference

**Primary**: [.specify/memory/constitution.md](../../.specify/memory/constitution.md)

**Nine Non-Negotiable Principles**:
1. Domain Language Consistency
2. Single-Partition Data Model (Cosmos) OR Normalized Schema (PostgreSQL)
3. Atomic State Transitions
4. Idempotent Message Handlers
5. Structured Observability (correlation IDs)
6. Message-Based Integration
7. Thin Message Handlers
8. Test Coverage Requirements (Domain 90%+, Application 80%+)
9. Technology Constraints (.NET 10, NServiceBus 9.x)

---

## Questions?

- **Domain standards**: Check `services/<domain>/docs/domain-specific-standards.md`
- **Project structure**: [copilot-instructions/project-structure.md](../../copilot-instructions/project-structure.md)
- **Messaging patterns**: [copilot-instructions/messaging-patterns.md](../../copilot-instructions/messaging-patterns.md)
- **Test conventions**: [copilot-instructions/testing-standards.md](../../copilot-instructions/testing-standards.md)
