# Research: Manual File Check Trigger API

**Date**: 2025-01-24  
**Feature**: 001-file-retrieval-config  
**Phase**: 0 (Outline & Research)

## Purpose

This document consolidates research findings for unknowns identified during Technical Context analysis. Since this is an enhancement to an existing, mature codebase, most patterns and infrastructure already exist. Research focuses on validating assumptions and documenting existing patterns for reuse.

---

## Research Areas

### R1: Security Pattern for Manual Trigger Endpoint

**Question**: How should the API endpoint extract and validate user identity for audit trail in the `FileCheckTriggered` event?

**Findings**:
- Existing pattern in `ConfigurationController.cs` (lines 56-62):
  - `GetUserIdFromClaims()` extracts user ID from JWT claims
  - Priority: `ClaimTypes.NameIdentifier` → `"sub"` → `ClaimTypes.Email` → `"unknown-user"`
  - Used in existing endpoints for audit logging
- `GetClientIdFromClaims()` extracts client ID (lines 41-49) with mandatory validation
- Both methods already handle missing claims gracefully with appropriate error messages

**Decision**: Reuse existing `GetUserIdFromClaims()` helper method to populate "triggered by" field in API response and pass through command as metadata if needed for event.

**Rationale**: 
- Established pattern proven in production
- Consistent audit trail across all manual operations
- No new security mechanism required

**Alternatives Considered**:
- Creating new claim extraction method → Rejected: unnecessary duplication
- Passing entire ClaimsPrincipal → Rejected: violates separation of concerns

---

### R2: Event Publishing Location in Handler

**Question**: Should `FileCheckTriggered` event be published BEFORE or AFTER calling `FileCheckService.ExecuteCheckAsync()`?

**Findings**:
- Spec requirement (AC-4): "When the handler begins processing, then the system publishes a FileCheckTriggered event **before executing the file check**"
- Existing handler structure (ExecuteFileCheckHandler.cs):
  - Line 40-46: Load configuration
  - Line 48-87: Check IsActive
  - Line 89-93: Call `FileCheckService.ExecuteCheckAsync()` (the actual file check)
  - Line 95-129: Process discovered files and publish `FileCheckCompleted`
- Event should capture "intention to check" not "result of check" (covered by FileCheckCompleted/FileCheckFailed)

**Decision**: Publish `FileCheckTriggered` event immediately after loading configuration and validating IsActive, before calling `FileCheckService.ExecuteCheckAsync()`.

**Rationale**:
- Captures audit trail even if file check fails mid-execution
- Follows spec requirement for "before executing"
- Enables monitoring of queued vs completed checks
- Provides consistent tracking regardless of execution outcome

**Alternatives Considered**:
- Publishing after ExecuteCheckAsync completes → Rejected: contradicts spec ("before executing")
- Publishing at very start before loading config → Rejected: event should include configuration details

---

### R3: Idempotency Strategy for FileCheckTriggered Event

**Question**: How to ensure exactly-once semantics for `FileCheckTriggered` event when handler is replayed?

**Findings**:
- NServiceBus guarantees at-least-once delivery (handlers may replay on failure/retry)
- Existing event patterns use `IdempotencyKey` field:
  - `FileCheckCompleted`: `"{ClientId}:{ConfigurationId}:completed:{ExecutionId}"` (line 116)
  - `FileCheckFailed`: `"{ClientId}:{ConfigurationId}:failed:{ExecutionId}"` (line 61)
- ExecutionId is generated by `FileCheckService.ExecuteCheckAsync()` (inside the service call)
- Problem: If handler retries before ExecuteCheckAsync is called, ExecutionId doesn't exist yet

**Decision**: Generate `ExecutionId` in handler before calling service. Pass to service as parameter. Use in `IdempotencyKey` format: `"{ClientId}:{ConfigurationId}:triggered:{ExecutionId}"`.

**Rationale**:
- ExecutionId generated once per handler invocation
- IdempotencyKey remains stable across retries
- Service can use provided ExecutionId instead of generating new one
- Aligns with existing idempotency patterns

**Alternatives Considered**:
- Using timestamp in IdempotencyKey → Rejected: changes on each retry (not idempotent)
- Using message.MessageId → Rejected: doesn't include domain identifiers (harder to query/debug)

---

### R4: API Response Model Design

**Question**: What data should the trigger endpoint return in 202 Accepted response?

**Findings**:
- Existing async pattern examples in codebase:
  - `CreateConfiguration` returns 202 Accepted with `ConfigurationResponse` (full configuration details)
  - Response includes: `ConfigurationId`, `ClientId`, `Name`, `Protocol`, timestamps, etc.
- Spec defines successful response fields (spec.md lines 118-121):
  - Configuration ID confirmed
  - Execution ID for tracking
  - Trigger timestamp
  - Confirmation message

**Decision**: Create `TriggerFileCheckResponse` DTO with minimal fields:
```csharp
public record TriggerFileCheckResponse
{
    public required Guid ConfigurationId { get; init; }
    public required Guid ExecutionId { get; init; }
    public required DateTimeOffset TriggeredAt { get; init; }
    public required string Message { get; init; }
}
```

**Rationale**:
- Provides execution tracking ID (key requirement for support engineers)
- Confirms operation acceptance
- Timestamp for audit purposes
- Minimal payload (fast response)
- Follows REST 202 Accepted pattern (accepted but not completed)

**Alternatives Considered**:
- Returning full configuration details → Rejected: unnecessary data for trigger operation
- Returning only ExecutionId → Rejected: less user-friendly (missing context)

---

### R5: Error Handling Strategy for Configuration Validation

**Question**: What validation should occur before sending the `ExecuteFileCheck` command, and what error codes should be returned?

**Findings**:
- Spec defines error responses (spec.md lines 123-129):
  - **400 Bad Request**: Configuration inactive/disabled
  - **403 Forbidden**: Configuration belongs to different client
  - **404 Not Found**: Configuration doesn't exist
  - **500 Internal Server Error**: System error during command sending
- Existing `ConfigurationService` has `GetByIdAsync(clientId, configurationId)` method
- Returns null if not found OR if clientId doesn't match (security trimming at repository level)
- Existing handler checks `IsActive` field (ExecuteFileCheckHandler.cs line 81-87)

**Decision**: API endpoint performs two validation steps before sending command:
1. **Existence + Security**: Call `ConfigurationService.GetByIdAsync(clientId, configId)`
   - If null → Return 404 Not Found (cannot distinguish not exists vs wrong client for security)
2. **Active Status**: Check `configuration.IsActive`
   - If false → Return 400 Bad Request with message "Configuration is inactive"
3. **Command Send**: Wrap in try/catch for messaging errors → Return 500 on exception

**Rationale**:
- Fast-fail before expensive command sending
- Clear error messages for support engineers
- Security trimming handled by repository (existing pattern)
- 404 for both "not found" and "wrong client" prevents information disclosure

**Alternatives Considered**:
- Returning 403 when clientId mismatch → Rejected: leaks configuration existence to unauthorized users
- Letting handler validate → Rejected: wastes message processing and creates confusing error flow
- Separate 404 and 403 codes → Rejected: violates security principle (don't reveal what you don't own)

---

### R6: User Identity Flow Through Command

**Question**: How should user identity (support engineer) flow from API to event for "triggered by" field?

**Findings**:
- Existing `ExecuteFileCheck` command structure (ExecuteFileCheck.cs):
  - Standard fields: `MessageId`, `CorrelationId`, `OccurredUtc`, `IdempotencyKey`
  - Domain fields: `ClientId`, `ConfigurationId`, `ScheduledExecutionTime`, `IsManualTrigger`
  - No "user" or "triggeredBy" field currently
- Spec requires event to capture "who triggered" (spec.md line 88)
- For scheduled executions, triggered by = "Scheduler" (not a user)
- For manual triggers, triggered by = support engineer user ID

**Decision**: Add optional `TriggeredBy` field to `ExecuteFileCheck` command:
```csharp
public string? TriggeredBy { get; init; } // null for scheduled, userId for manual
```

**Rationale**:
- Backward compatible (nullable, optional)
- Scheduled executions can omit field (null = "Scheduler")
- Manual triggers populate from `GetUserIdFromClaims()`
- Event can use this field directly without additional lookups
- Maintains command as single source of truth for execution context

**Alternatives Considered**:
- Storing user ID in message headers → Rejected: harder to test and access in handler
- Looking up user from CorrelationId → Rejected: CorrelationId is not user-specific
- Not tracking user → Rejected: violates audit requirement (spec AC-4)

---

### R7: Execution ID Generation and Propagation

**Question**: Where should ExecutionId be generated, and how does it flow through the system?

**Findings**:
- Current implementation: `FileCheckService.ExecuteCheckAsync()` generates ExecutionId internally (inside service)
- Handler receives ExecutionId in `result.ExecutionId` after service call completes
- Problem: Need ExecutionId BEFORE service call to ensure idempotency (see R3)

**Decision**: 
1. Generate `ExecutionId = Guid.NewGuid()` in handler before any processing
2. Pass ExecutionId to `FileCheckService.ExecuteCheckAsync()` as new parameter
3. Service uses provided ExecutionId instead of generating new one
4. Use ExecutionId in `FileCheckTriggered` event IdempotencyKey

**Implementation Changes Required**:
- Modify `FileCheckService.ExecuteCheckAsync()` signature to accept `Guid executionId`
- Update handler to generate and pass ExecutionId
- Update service to use provided ExecutionId in execution record

**Rationale**:
- Enables idempotent event publishing
- ExecutionId stable across handler retries
- Service remains testable (can inject specific ExecutionId)
- Maintains single execution tracking across all operations

**Alternatives Considered**:
- Using message.MessageId as ExecutionId → Rejected: MessageId is message-specific, not execution-specific (same execution can have multiple message retries)
- Generating in service as before → Rejected: breaks idempotency (new ID on each retry)

---

## Summary of Decisions

| Research Area | Decision | Impact |
|--------------|----------|--------|
| **R1: Security Pattern** | Reuse `GetUserIdFromClaims()` helper | No new code, proven pattern |
| **R2: Event Timing** | Publish after config load, before file check | Ensures audit trail for all attempts |
| **R3: Idempotency** | Generate ExecutionId in handler | Requires service signature change |
| **R4: Response Model** | Minimal DTO with 4 fields | New DTO class needed |
| **R5: Validation Strategy** | Two-step validation (existence + active status) | API validates before sending command |
| **R6: User Identity Flow** | Add optional `TriggeredBy` field to command | Command contract change (backward compatible) |
| **R7: ExecutionId Generation** | Generate in handler, pass to service | Service signature change required |

---

## Technical Unknowns Resolved

✅ **How to ensure idempotent event publishing?** → Generate ExecutionId in handler before service call  
✅ **How to track manual vs scheduled triggers?** → Use existing `IsManualTrigger` field + new `TriggeredBy` field  
✅ **What validation before sending command?** → Check existence + active status in API  
✅ **How to extract user identity?** → Reuse existing `GetUserIdFromClaims()` helper  
✅ **What error codes for different failure modes?** → 404 (not found OR wrong client), 400 (inactive), 403 (not needed per security pattern), 500 (system error)  
✅ **Where to publish FileCheckTriggered?** → In handler after loading config, before file check execution

---

## Open Questions / Deferred Decisions

*None. All unknowns resolved. Feature is straightforward enhancement with clear patterns.*

---

## Next Phase

**Phase 1: Design & Contracts** - Ready to proceed with:
- `data-model.md` - Document entity changes (ExecuteFileCheck command modification)
- `contracts/FileCheckTriggered.md` - Event contract specification
- `quickstart.md` - Developer guide for adding similar manual trigger endpoints
- Update agent context with new patterns
