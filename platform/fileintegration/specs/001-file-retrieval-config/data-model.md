# Data Model: Manual File Check Trigger API

**Date**: 2025-01-24  
**Feature**: 001-file-retrieval-config  
**Phase**: 1 (Design & Contracts)

## Purpose

This document defines the data structures for the Manual File Check Trigger API enhancement. Since this is a small enhancement to existing infrastructure, most entities remain unchanged. This document focuses on the delta: new event, command modification, and response DTOs.

---

## Entity Changes

### Existing Entities (No Changes)

**FileRetrievalConfiguration** - No changes
- Already has all required fields: `ClientId`, `ConfigurationId`, `Name`, `IsActive`, protocol settings, schedule
- API reads this entity for validation only

**FileRetrievalExecution** - No changes
- Already tracks execution results with `ExecutionId`, status, files found, duration
- Created by `FileCheckService` (existing behavior)

**DiscoveredFile** - No changes
- Already tracks discovered files per execution
- Created by `FileCheckService` when files are found

---

## Message Contract Changes

### Modified Command: ExecuteFileCheck

**Purpose**: Trigger a file check for a specific configuration (existing command, minor enhancement)

**Location**: `src/FileRetrieval.Contracts/Commands/ExecuteFileCheck.cs`

**Changes Required**:
```csharp
public record ExecuteFileCheck : ICommand
{
    // Standard message fields (existing)
    public Guid MessageId { get; init; }
    public required string CorrelationId { get; init; }
    public DateTimeOffset OccurredUtc { get; init; }
    public required string IdempotencyKey { get; init; }
    
    // File Retrieval specific (existing)
    public required string ClientId { get; init; }
    public Guid ConfigurationId { get; init; }
    public DateTimeOffset ScheduledExecutionTime { get; init; }
    public bool IsManualTrigger { get; init; }  // Already exists
    
    // ✨ NEW FIELD
    /// <summary>
    /// User identifier who triggered the check (manual) or "Scheduler" (scheduled).
    /// Null for scheduled executions (defaults to "Scheduler" in event).
    /// </summary>
    public string? TriggeredBy { get; init; }
}
```

**Rationale**: 
- Backward compatible (nullable field, existing messages still valid)
- Enables audit trail for manual triggers
- Scheduled executions can omit field (null check in handler)

**Validation Rules**:
- `ClientId` required and non-empty (existing)
- `ConfigurationId` must be valid Guid (existing)
- `CorrelationId` required (existing)
- `IdempotencyKey` required and unique (existing)
- `TriggeredBy` optional (null allowed)

---

### New Event: FileCheckTriggered

**Purpose**: Notify subscribers that a file check has been initiated, capturing trigger source and context for audit/monitoring.

**Location**: `src/FileRetrieval.Contracts/Events/FileCheckTriggered.cs`

**Event Structure**:
```csharp
public record FileCheckTriggered : IEvent
{
    // Standard message fields
    public Guid MessageId { get; init; }
    public required string CorrelationId { get; init; }
    public DateTimeOffset OccurredUtc { get; init; }
    public required string IdempotencyKey { get; init; }
    
    // File Retrieval context
    public required string ClientId { get; init; }
    public required Guid ConfigurationId { get; init; }
    public required string ConfigurationName { get; init; }
    public required string Protocol { get; init; }
    
    // Execution tracking
    public required Guid ExecutionId { get; init; }
    public required DateTimeOffset ScheduledExecutionTime { get; init; }
    
    // Trigger context
    public required bool IsManualTrigger { get; init; }
    public required string TriggeredBy { get; init; }  // User ID or "Scheduler"
}
```

**Field Descriptions**:

| Field | Type | Purpose | Source |
|-------|------|---------|--------|
| `MessageId` | Guid | Unique event identifier | Auto-generated by handler |
| `CorrelationId` | string | Request correlation ID | From `ExecuteFileCheck` command |
| `OccurredUtc` | DateTimeOffset | When event occurred | `DateTimeOffset.UtcNow` |
| `IdempotencyKey` | string | Deduplication key | `"{ClientId}:{ConfigurationId}:triggered:{ExecutionId}"` |
| `ClientId` | string | Client identifier | From command |
| `ConfigurationId` | Guid | Configuration identifier | From command |
| `ConfigurationName` | string | Human-readable name | From loaded configuration entity |
| `Protocol` | string | Protocol type (FTP, HTTPS, Blob) | From configuration.ProtocolSettings.ProtocolType |
| `ExecutionId` | Guid | Unique execution tracking ID | Generated in handler |
| `ScheduledExecutionTime` | DateTimeOffset | When check was scheduled/triggered | From command or `DateTimeOffset.UtcNow` for manual |
| `IsManualTrigger` | bool | Manual (true) or scheduled (false) | From command |
| `TriggeredBy` | string | User ID or "Scheduler" | From command.TriggeredBy ?? "Scheduler" |

**Validation Rules**:
- All required fields must have non-null/non-default values
- `IdempotencyKey` must be unique per execution
- `CorrelationId` must match command's CorrelationId
- `TriggeredBy` defaults to "Scheduler" if command field is null

**Idempotency Strategy**:
- **IdempotencyKey Format**: `"{ClientId}:{ConfigurationId}:triggered:{ExecutionId}"`
- **Uniqueness Guarantee**: ExecutionId generated once per handler invocation, stable across retries
- **Deduplication**: NServiceBus outbox ensures event published exactly once per unique IdempotencyKey
- **Replay Behavior**: Handler replays after failure use same ExecutionId → same IdempotencyKey → duplicate event suppressed

**Subscribers** (expected consumers):
- Audit logging systems (capture who triggered what, when)
- Monitoring dashboards (track manual vs scheduled check ratio)
- Analytics systems (trend analysis of trigger sources)

---

## API Models

### New Response DTO: TriggerFileCheckResponse

**Purpose**: Return confirmation and tracking information for manual file check trigger

**Location**: `src/FileRetrieval.API/Models/TriggerFileCheckResponse.cs`

**Structure**:
```csharp
namespace RiskInsure.FileRetrieval.API.Models;

/// <summary>
/// Response returned when a file check is manually triggered.
/// Provides execution tracking ID and confirmation details.
/// </summary>
public record TriggerFileCheckResponse
{
    /// <summary>
    /// The configuration ID that was triggered
    /// </summary>
    public required Guid ConfigurationId { get; init; }
    
    /// <summary>
    /// Unique execution ID for tracking this file check execution.
    /// Use this ID to query execution history and results.
    /// </summary>
    public required Guid ExecutionId { get; init; }
    
    /// <summary>
    /// Timestamp when the trigger was accepted
    /// </summary>
    public required DateTimeOffset TriggeredAt { get; init; }
    
    /// <summary>
    /// Human-readable confirmation message
    /// </summary>
    public required string Message { get; init; }
}
```

**Usage Pattern**:
```json
{
  "configurationId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "executionId": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
  "triggeredAt": "2025-01-24T14:32:15.123Z",
  "message": "File check triggered successfully. Use executionId to track progress."
}
```

**Validation**: All fields required (non-nullable) except Message can have standard template.

---

## Data Flow Diagrams

### Manual Trigger Flow

```text
┌─────────────┐
│   Client    │ POST /api/configuration/{id}/trigger
│  (Support)  │ Headers: Authorization: Bearer <JWT>
└──────┬──────┘
       │
       ↓
┌────────────────────────────────────────────────────────┐
│ ConfigurationController.TriggerFileCheck()             │
│ 1. Extract clientId from JWT (GetClientIdFromClaims)   │
│ 2. Extract userId from JWT (GetUserIdFromClaims)       │
│ 3. Validate configuration exists + IsActive            │
│    - Call ConfigurationService.GetByIdAsync()          │
│    - Check IsActive = true                             │
│ 4. Generate ExecutionId = Guid.NewGuid()               │
│ 5. Send ExecuteFileCheck command via NServiceBus       │
│    - IsManualTrigger = true                            │
│    - TriggeredBy = userId                              │
│ 6. Return 202 Accepted with TriggerFileCheckResponse   │
└────────────────┬───────────────────────────────────────┘
                 │
                 ↓ ExecuteFileCheck command (via Azure Service Bus)
                 │
┌────────────────────────────────────────────────────────┐
│ ExecuteFileCheckHandler.Handle()                       │
│ 1. Load configuration from repository                  │
│ 2. Validate IsActive (skip if false)                   │
│ 3. ✨ Publish FileCheckTriggered event                 │
│    - IdempotencyKey = "{ClientId}:{ConfigurationId}:   │
│                        triggered:{ExecutionId}"        │
│    - TriggeredBy = command.TriggeredBy ?? "Scheduler"  │
│ 4. Call FileCheckService.ExecuteCheckAsync()           │
│    - Pass ExecutionId from command context             │
│ 5. Process discovered files (existing)                 │
│ 6. Publish FileCheckCompleted/Failed (existing)        │
└────────────────────────────────────────────────────────┘
```

### Idempotency Guarantee Flow

```text
Request 1: POST /trigger → ExecutionId=ABC → Command sent → Handler processes → FileCheckTriggered published
Request 2: (retry of same request) → NEW ExecutionId=XYZ → NEW Command → NEW Handler → NEW FileCheckTriggered
                                                                                        ↑ Different execution!

Handler Retry Flow:
Handler starts → Generate ExecutionId=ABC → Publish FileCheckTriggered (Key=ABC) → FAIL → Retry
Handler retries → Use SAME ExecutionId=ABC → Publish FileCheckTriggered (Key=ABC) → Outbox deduplicates ✓
```

**Key Insight**: ExecutionId must be generated in handler (not in API, not in service) to ensure stable idempotency across handler retries while allowing separate executions for separate API requests.

---

## Persistence Changes

### Cosmos DB Structure

**Container**: `file-retrieval` (existing)  
**Partition Key**: `/clientId` (existing)  
**Document Types**: `FileRetrievalConfiguration`, `FileRetrievalExecution`, `DiscoveredFile` (all existing)

**No schema changes required. No indexes to add.**

### State Transitions

**FileRetrievalConfiguration**:
- No state changes (read-only access from API)

**FileRetrievalExecution**:
- Created by `FileCheckService` with ExecutionId provided by handler (minor change to service signature)
- All state transitions remain unchanged

---

## Query Patterns

### Q1: Validate Configuration Existence and Ownership

**Query**: `GetByIdAsync(clientId, configurationId)`  
**Repository**: `IFileRetrievalConfigurationRepository` (existing method)  
**Partition**: Single partition (`/clientId`)  
**Performance**: Point read (1 RU)  
**Security**: Repository automatically filters by clientId (security trimming)

### Q2: Check Configuration Active Status

**Query**: In-memory check after loading entity  
**Pattern**: `if (!configuration.IsActive) return BadRequest;`  
**Performance**: No additional query (piggyback on Q1)

---

## Validation Rules Summary

| Validation | Layer | Rule | Error Code |
|------------|-------|------|------------|
| JWT present | Middleware | Token required | 401 Unauthorized |
| clientId claim exists | API Controller | `GetClientIdFromClaims()` | 401 Unauthorized |
| Configuration exists | API Controller | `GetByIdAsync()` != null | 404 Not Found |
| Client owns config | Repository | Partition-scoped query | 404 Not Found (implicit) |
| Configuration active | API Controller | `IsActive == true` | 400 Bad Request |
| Command send succeeds | API Controller | Try/catch messaging | 500 Internal Server Error |

---

## Performance Considerations

### API Endpoint Performance

**Target**: <2 seconds (SC-001)

**Operations**:
1. JWT claim extraction: <1ms (in-memory)
2. Configuration query: ~5-10ms (point read, single partition)
3. IsActive check: <1ms (in-memory)
4. Command send: ~10-50ms (Azure Service Bus enqueue)
5. Response serialization: <1ms

**Total Expected**: ~20-70ms (well under 2-second target)

### Handler Performance

**Target**: <500ms p95 (message processing)

**New Operation Added**:
- Publish `FileCheckTriggered` event: ~10-20ms

**Impact**: Negligible (handler already publishes 1-2 events at end of processing)

---

## Security Model

### Multi-Tenancy Enforcement

**Partition-Based Isolation**:
- All queries use `/clientId` partition key
- Repository layer enforces client scoping
- No cross-client data leakage possible

**JWT Claims Extraction**:
- `clientId` claim: Identifies which client the user represents (required)
- `sub` / `NameIdentifier` claim: User identity for audit trail (required)
- No request body fields used for security (claims only)

**Authorization Flow**:
```text
1. Middleware validates JWT signature
2. Policy "ClientAccess" checks clientId claim exists
3. Controller extracts clientId from claims (never from request)
4. Repository queries scoped by clientId (automatic filtering)
5. Any non-match returns 404 (doesn't leak existence)
```

### Information Disclosure Prevention

**Scenario**: User from ClientA tries to trigger configuration owned by ClientB

**Current Response**: 404 Not Found  
**Rationale**: Don't reveal whether configuration exists if user doesn't own it  
**Alternative Rejected**: 403 Forbidden (leaks existence information)

---

## Event Schema Design

### FileCheckTriggered Event

**Category**: Audit/Monitoring event (non-transactional)  
**Delivery**: At-least-once with outbox deduplication  
**Retention**: Per subscriber settings (e.g., 30-90 days)

**Schema Version**: 1.0

**JSON Example** (scheduled trigger):
```json
{
  "messageId": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
  "correlationId": "client123-config456-20250124143215",
  "occurredUtc": "2025-01-24T14:32:15.123Z",
  "idempotencyKey": "client123:config456:triggered:abc-def-123",
  "clientId": "client123",
  "configurationId": "config456",
  "configurationName": "Daily Enrollment Files",
  "protocol": "SFTP",
  "executionId": "abc-def-123",
  "scheduledExecutionTime": "2025-01-24T14:30:00Z",
  "isManualTrigger": false,
  "triggeredBy": "Scheduler"
}
```

**JSON Example** (manual trigger):
```json
{
  "messageId": "8d0e7789-8536-51de-a55c-3d073f00bf8",
  "correlationId": "manual-trigger-20250124143530",
  "occurredUtc": "2025-01-24T14:35:30.456Z",
  "idempotencyKey": "client123:config456:triggered:xyz-789-456",
  "clientId": "client123",
  "configurationId": "config456",
  "configurationName": "Daily Enrollment Files",
  "protocol": "SFTP",
  "executionId": "xyz-789-456",
  "scheduledExecutionTime": "2025-01-24T14:35:30.456Z",
  "isManualTrigger": true,
  "triggeredBy": "user-abc-123"
}
```

**Field Constraints**:
- `ClientId`: Must match configuration's partition key
- `ExecutionId`: Must be unique per file check execution (Guid)
- `IdempotencyKey`: Must follow format `"{ClientId}:{ConfigurationId}:triggered:{ExecutionId}"`
- `TriggeredBy`: Never null (defaults to "Scheduler" if command omits)
- `Protocol`: Enum string value ("FTP", "HTTPS", "AzureBlob")

---

## API Response Models

### TriggerFileCheckResponse

**Purpose**: Confirm acceptance of manual trigger request and provide tracking ID

**Location**: `src/FileRetrieval.API/Models/TriggerFileCheckResponse.cs`

**Schema**:
```csharp
namespace RiskInsure.FileRetrieval.API.Models;

/// <summary>
/// Response returned when a file check is manually triggered via API.
/// Provides execution tracking ID for monitoring and status queries.
/// </summary>
public record TriggerFileCheckResponse
{
    /// <summary>
    /// Configuration ID that was triggered
    /// </summary>
    public required Guid ConfigurationId { get; init; }
    
    /// <summary>
    /// Unique execution ID for tracking this file check.
    /// Use with ExecutionHistory API to monitor progress and results.
    /// </summary>
    public required Guid ExecutionId { get; init; }
    
    /// <summary>
    /// When the trigger request was accepted (UTC)
    /// </summary>
    public required DateTimeOffset TriggeredAt { get; init; }
    
    /// <summary>
    /// Confirmation message with next steps
    /// </summary>
    public required string Message { get; init; }
}
```

**Example Response**:
```json
{
  "configurationId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "executionId": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
  "triggeredAt": "2025-01-24T14:32:15.123Z",
  "message": "File check triggered successfully. Use executionId to track progress via /api/executionhistory/{executionId}"
}
```

**Standard Message Template**: `"File check triggered successfully. Use executionId to track progress via /api/executionhistory/{executionId}"`

---

## Integration Points

### Existing Services Used

**ConfigurationService** (Application layer):
- `GetByIdAsync(clientId, configurationId)` - Load and validate configuration
- Returns null if not found OR wrong client (security trimming)

**IMessageSession** (NServiceBus):
- `Send(ExecuteFileCheck)` - Send command to Worker endpoint
- Throws exception if messaging infrastructure unavailable

**IFileRetrievalConfigurationRepository** (Domain):
- `GetByIdAsync(clientId, configurationId)` - Repository query
- Used by ConfigurationService (abstraction layer)

### New Integration

**FileCheckService** (Application layer):
- **Current signature**: `Task<FileCheckResult> ExecuteCheckAsync(FileRetrievalConfiguration configuration, DateTimeOffset scheduledTime, CancellationToken ct)`
- **New signature**: `Task<FileCheckResult> ExecuteCheckAsync(FileRetrievalConfiguration configuration, DateTimeOffset scheduledTime, Guid executionId, CancellationToken ct)`
- **Change**: Accept `executionId` parameter instead of generating internally
- **Impact**: Existing scheduled flow must pass `Guid.NewGuid()` when calling service

---

## Backward Compatibility

### Command Contract Changes

**ExecuteFileCheck** - Adding nullable `TriggeredBy` field:
- ✅ Backward compatible: Existing scheduled messages omit field (null allowed)
- ✅ Existing handler code: Can handle null (defaults to "Scheduler")
- ✅ No message version required (additive change)

### Service Signature Changes

**FileCheckService.ExecuteCheckAsync** - Adding `executionId` parameter:
- ⚠️ **Breaking change** for callers (signature modified)
- ✅ **Mitigation**: Only 2 callers:
  1. `ExecuteFileCheckHandler` (we're modifying)
  2. Unit tests (we'll update)
- ✅ **Impact**: Low (internal service, controlled callers)

### Event Publishing

**New FileCheckTriggered event**:
- ✅ No existing subscribers (new event)
- ✅ Subscribers opt-in (publish doesn't break anything)
- ✅ Future subscribers can start consuming immediately

---

## Error Scenarios

### ES-1: Configuration Not Found or Wrong Client

**Trigger**: `GetByIdAsync()` returns null  
**Response**: 404 Not Found  
**Body**: `{ "error": "Configuration not found or access denied" }`  
**Logging**: Warning level with clientId and configurationId  
**Command Sent**: No (fail fast)

### ES-2: Configuration Inactive

**Trigger**: `configuration.IsActive == false`  
**Response**: 400 Bad Request  
**Body**: `{ "error": "Configuration is inactive and cannot be triggered" }`  
**Logging**: Warning level  
**Command Sent**: No (fail fast)

### ES-3: Message Bus Unavailable

**Trigger**: `messageSession.Send()` throws exception  
**Response**: 500 Internal Server Error  
**Body**: `{ "error": "Failed to trigger file check. Please try again." }`  
**Logging**: Error level with exception details  
**Command Sent**: Failed (exception thrown)

### ES-4: Handler Retry with Same ExecutionId

**Trigger**: Handler fails after publishing event, NServiceBus retries  
**Behavior**: Same ExecutionId used → Same IdempotencyKey → Outbox suppresses duplicate event  
**Outcome**: Exactly-once event delivery guaranteed  
**Logging**: Debug level "Event already published" (outbox deduplication)

---

## Testing Strategy

### API Integration Tests (Playwright)

**Test File**: `test/FileRetrieval.Integration.Tests/Controllers/ConfigurationController.TriggerTests.cs`

**Scenarios**:
1. `TriggerFileCheck_ValidConfiguration_Returns202WithExecutionId`
2. `TriggerFileCheck_ConfigurationNotFound_Returns404`
3. `TriggerFileCheck_InactiveConfiguration_Returns400`
4. `TriggerFileCheck_WrongClient_Returns404` (security trimming)
5. `TriggerFileCheck_MissingClientIdClaim_Returns401`

### Handler Unit Tests (xUnit)

**Test File**: `test/FileRetrieval.Application.Tests/MessageHandlers/ExecuteFileCheckHandlerTests.cs`

**Scenarios**:
1. `Handle_ManualTrigger_PublishesFileCheckTriggeredEvent`
2. `Handle_ScheduledTrigger_PublishesFileCheckTriggeredEventWithScheduler`
3. `Handle_EventIdempotency_SameExecutionIdProducesSameIdempotencyKey`
4. `Handle_TriggeredByField_UsesCommandValueOrDefaultsToScheduler`

### Service Tests (xUnit)

**Test File**: `test/FileRetrieval.Application.Tests/Services/FileCheckServiceTests.cs`

**Scenarios**:
1. `ExecuteCheckAsync_WithProvidedExecutionId_UsesProvidedId` (new test for signature change)

---

## Migration Plan

**No database migrations required** - This feature:
- Adds API endpoint (code-only)
- Adds event contract (message schema)
- Modifies handler (code-only)
- Modifies service signature (code-only)

**Deployment Order**:
1. Deploy Worker first (with updated handler and service)
2. Deploy API second (with new endpoint)
3. No downtime required (backward compatible command contract)

**Rollback Plan**:
- Revert API deployment (removes trigger endpoint)
- Event publishing in handler is harmless if no subscribers
- Can roll back independently

---

## Summary

This data model focuses on **minimal change for maximum value**:

✅ **New Event**: `FileCheckTriggered` (8 fields, follows existing event patterns)  
✅ **Command Enhancement**: `TriggeredBy` field added to `ExecuteFileCheck` (backward compatible)  
✅ **API Response**: `TriggerFileCheckResponse` (4 fields, minimal payload)  
✅ **Service Change**: `ExecuteCheckAsync` accepts `executionId` parameter (controlled breaking change)  
✅ **No database changes**: Uses existing entities and queries  
✅ **No new projects**: All changes in existing layers  
✅ **Idempotency**: Guaranteed via ExecutionId generation strategy  
✅ **Security**: Existing JWT + repository patterns enforced

**Complexity**: Low (8-10 files touched, ~200 lines of new code)
