# Command Contracts: Client File Retrieval Configuration

**Date**: 2025-01-24  
**Feature**: 001-file-retrieval-config  
**Phase**: Phase 1 - Design

## Overview

This document defines all command message contracts for the Client File Retrieval Configuration feature. Commands are imperative instructions sent to specific endpoints via NServiceBus. All commands follow the RiskInsure naming convention: `Verb + Noun` (e.g., `ExecuteFileCheck`, `CreateConfiguration`).

Commands integrate with the workflow orchestration platform via Azure Service Bus and support the idempotent message handling pattern (Constitution Principle IV).

---

## Message Standards

All commands MUST include:
- `MessageId` (Guid) - Unique message identifier (NServiceBus auto-generated)
- `CorrelationId` (string) - Trace messages across distributed calls
- `OccurredUtc` (DateTimeOffset) - When command was created
- `IdempotencyKey` (string) - Unique key for duplicate detection
- `ClientId` (string) - Multi-tenant isolation

---

## 1. ExecuteFileCheck

**Purpose**: Triggers a file check for a specific FileRetrievalConfiguration.

**Sent By**: SchedulerHostedService (when schedule fires)  
**Handled By**: `ExecuteFileCheckHandler` → `FileCheckService.ExecuteCheck()`

**Properties**:

```csharp
public record ExecuteFileCheck : ICommand
{
    public Guid MessageId { get; init; }
    public string CorrelationId { get; init; } = default!;
    public DateTimeOffset OccurredUtc { get; init; }
    public string IdempotencyKey { get; init; } = default!;
    
    // File Retrieval specific
    public string ClientId { get; init; } = default!;
    public Guid ConfigurationId { get; init; }
    public DateTimeOffset ScheduledExecutionTime { get; init; }
    public bool IsManualTrigger { get; init; } // false = scheduled, true = manual (API triggered)
}
```

**Validation**:
- `ClientId` must not be empty
- `ConfigurationId` must not be empty
- `ScheduledExecutionTime` must not be future date (allow small clock skew: +5 minutes)
- `CorrelationId` format: `{ClientId}-{ConfigurationId}-{ExecutionTimestamp}` (for tracing)

**Idempotency**:
- `IdempotencyKey`: `{ClientId}:{ConfigurationId}:{ScheduledExecutionTime:yyyyMMddHHmmss}`
- Handler checks for existing `FileRetrievalExecution` with same key before processing
- If execution already exists, return early (idempotent)

**Handler Responsibilities**:
1. Validate message structure
2. Load FileRetrievalConfiguration from repository (by ConfigurationId, scoped to ClientId)
3. Check if configuration is active (IsActive = true)
4. Delegate to `FileCheckService.ExecuteCheck(configuration, scheduledTime)`
5. Publish `FileCheckCompleted` or `FileCheckFailed` event

**Error Scenarios**:
- Configuration not found → Log warning, do not retry (invalid schedule)
- Configuration inactive → Log info, do not retry (expected behavior)
- Connection failure → Retry 3 times with exponential backoff, then publish `FileCheckFailed` event

---

## 2. CreateConfiguration

**Purpose**: Creates a new FileRetrievalConfiguration.

**Sent By**: API Controller (`ConfigurationController.CreateConfiguration`)  
**Handled By**: `CreateConfigurationHandler` → `ConfigurationService.CreateAsync()`

**Properties**:

```csharp
public record CreateConfiguration : ICommand
{
    public Guid MessageId { get; init; }
    public string CorrelationId { get; init; } = default!;
    public DateTimeOffset OccurredUtc { get; init; }
    public string IdempotencyKey { get; init; } = default!;
    
    // Configuration details
    public string ClientId { get; init; } = default!;
    public Guid ConfigurationId { get; init; } // Pre-generated by API
    public string Name { get; init; } = default!;
    public string? Description { get; init; }
    public string Protocol { get; init; } = default!; // "Ftp", "Https", "AzureBlob"
    public Dictionary<string, object> ProtocolSettings { get; init; } = default!;
    public string FilePathPattern { get; init; } = default!;
    public string FilenamePattern { get; init; } = default!;
    public string? FileExtension { get; init; }
    public ScheduleDefinitionDto Schedule { get; init; } = default!;
    public List<EventDefinitionDto> EventsToPublish { get; init; } = default!;
    public List<CommandDefinitionDto>? CommandsToSend { get; init; }
    public string CreatedBy { get; init; } = default!; // User ID from JWT claims
}
```

**Validation**:
- All required fields present (ClientId, Name, Protocol, etc.)
- Protocol is valid enum value ("Ftp", "Https", "AzureBlob")
- ProtocolSettings match protocol type (validated by ConfigurationService)
- FilePathPattern and FilenamePattern do not contain tokens in server/host portion
- Schedule.CronExpression is valid (NCrontab parser)
- EventsToPublish has at least one event
- CreatedBy matches authenticated user (security check in API layer)

**Idempotency**:
- `IdempotencyKey`: `{ClientId}:{ConfigurationId}`
- Handler checks for existing configuration with same ConfigurationId
- If exists, return early with existing configuration (idempotent)

**Handler Responsibilities**:
1. Validate message structure
2. Deserialize ProtocolSettings into appropriate concrete type (FtpSettings, HttpsSettings, etc.)
3. Validate token positions in file patterns (TokenReplacementService.Validate)
4. Delegate to `ConfigurationService.CreateAsync(configuration)`
5. Publish `ConfigurationCreated` event

**Error Scenarios**:
- Duplicate ConfigurationId → Idempotent (return existing)
- Invalid protocol settings → Return validation error (do not retry)
- Invalid cron expression → Return validation error (do not retry)
- Cosmos DB write failure → Retry 3 times, then return error

---

## 3. UpdateConfiguration

**Purpose**: Updates an existing FileRetrievalConfiguration.

**Sent By**: API Controller (`ConfigurationController.UpdateConfiguration`)  
**Handled By**: `UpdateConfigurationHandler` → `ConfigurationService.UpdateAsync()`

**Properties**:

```csharp
public record UpdateConfiguration : ICommand
{
    public Guid MessageId { get; init; }
    public string CorrelationId { get; init; } = default!;
    public DateTimeOffset OccurredUtc { get; init; }
    public string IdempotencyKey { get; init; } = default!;
    
    // Configuration details
    public string ClientId { get; init; } = default!;
    public Guid ConfigurationId { get; init; }
    public string Name { get; init; } = default!;
    public string? Description { get; init; }
    public string Protocol { get; init; } = default!;
    public Dictionary<string, object> ProtocolSettings { get; init; } = default!;
    public string FilePathPattern { get; init; } = default!;
    public string FilenamePattern { get; init; } = default!;
    public string? FileExtension { get; init; }
    public ScheduleDefinitionDto Schedule { get; init; } = default!;
    public List<EventDefinitionDto> EventsToPublish { get; init; } = default!;
    public List<CommandDefinitionDto>? CommandsToSend { get; init; }
    public bool IsActive { get; init; }
    public string LastModifiedBy { get; init; } = default!; // User ID from JWT claims
    public string ETag { get; init; } = default!; // Optimistic concurrency
}
```

**Validation**: Same as CreateConfiguration + ETag validation

**Idempotency**:
- `IdempotencyKey`: `{ClientId}:{ConfigurationId}:{ETag}`
- ETag ensures idempotency (same ETag = same state)
- If ETag mismatch, handler loads latest version and retries update logic

**Handler Responsibilities**:
1. Validate message structure
2. Load existing configuration (by ConfigurationId, scoped to ClientId)
3. Check ETag matches (optimistic concurrency)
4. Validate updated settings (protocol, tokens, cron expression)
5. Delegate to `ConfigurationService.UpdateAsync(configuration, etag)`
6. Publish `ConfigurationUpdated` event

**Error Scenarios**:
- Configuration not found → Return 404 (do not retry)
- ETag mismatch → Return 409 Conflict with latest ETag (client must reload and retry)
- Invalid settings → Return validation error (do not retry)
- Cosmos DB write failure → Retry 3 times, then return error

---

## 4. DeleteConfiguration

**Purpose**: Deletes (soft-delete by setting IsActive = false) a FileRetrievalConfiguration.

**Sent By**: API Controller (`ConfigurationController.DeleteConfiguration`)  
**Handled By**: `DeleteConfigurationHandler` → `ConfigurationService.DeleteAsync()`

**Properties**:

```csharp
public record DeleteConfiguration : ICommand
{
    public Guid MessageId { get; init; }
    public string CorrelationId { get; init; } = default!;
    public DateTimeOffset OccurredUtc { get; init; }
    public string IdempotencyKey { get; init; } = default!;
    
    // Configuration details
    public string ClientId { get; init; } = default!;
    public Guid ConfigurationId { get; init; }
    public string DeletedBy { get; init; } = default!; // User ID from JWT claims
    public string ETag { get; init; } = default!; // Optimistic concurrency
}
```

**Validation**:
- ClientId and ConfigurationId not empty
- ETag not empty

**Idempotency**:
- `IdempotencyKey`: `{ClientId}:{ConfigurationId}:{DeletedBy}:{OccurredUtc:yyyyMMddHHmmss}`
- Handler checks IsActive status; if already inactive, return success (idempotent)

**Handler Responsibilities**:
1. Validate message structure
2. Load configuration (by ConfigurationId, scoped to ClientId)
3. Check ETag matches (optimistic concurrency)
4. Set `IsActive = false`, `LastModifiedBy = DeletedBy`, `LastModifiedAt = OccurredUtc`
5. Delegate to `ConfigurationService.UpdateAsync()` (soft delete)
6. Publish `ConfigurationDeleted` event

**Notes**:
- Soft delete (IsActive = false) preserves execution history
- Scheduler ignores inactive configurations
- Hard delete (physical removal) is out of scope (admin operation via separate tool)

**Error Scenarios**:
- Configuration not found → Return 404 (do not retry)
- ETag mismatch → Return 409 Conflict (client must reload)
- Already deleted (IsActive = false) → Return success (idempotent)

---

## 5. ProcessDiscoveredFile

**Purpose**: Command sent to the workflow orchestration platform to process a discovered file. This command is sent FROM the file retrieval service TO the workflow platform.

**Sent By**: `FileCheckService` (when file is discovered)  
**Handled By**: Workflow orchestration platform (external bounded context)

**Properties**:

```csharp
public record ProcessDiscoveredFile : ICommand
{
    public Guid MessageId { get; init; }
    public string CorrelationId { get; init; } = default!;
    public DateTimeOffset OccurredUtc { get; init; }
    public string IdempotencyKey { get; init; } = default!;
    
    // File details
    public string ClientId { get; init; } = default!;
    public Guid ConfigurationId { get; init; }
    public Guid ExecutionId { get; init; }
    public Guid DiscoveredFileId { get; init; }
    public string FileUrl { get; init; } = default!;
    public string Filename { get; init; } = default!;
    public long? FileSize { get; init; }
    public DateTimeOffset? LastModified { get; init; }
    public DateTimeOffset DiscoveredAt { get; init; }
    
    // Configuration metadata
    public string ConfigurationName { get; init; } = default!;
    public string Protocol { get; init; } = default!;
    
    // Custom command data from CommandDefinition
    public Dictionary<string, object>? CommandData { get; init; }
}
```

**Validation**:
- ClientId, FileUrl, Filename not empty
- ConfigurationId, ExecutionId, DiscoveredFileId not empty

**Idempotency**:
- `IdempotencyKey`: `{ClientId}:{DiscoveredFileId}`
- Workflow platform handler checks for duplicate processing of same file

**Handler Responsibilities** (in workflow platform):
1. Validate message structure
2. Start workflow instance based on CommandData (workflowType, priority, etc.)
3. Workflow downloads file from FileUrl (if needed)
4. Workflow processes file content (parsing, validation, business logic)

**Notes**:
- This command is defined in `FileRetrieval.Contracts` but handled by workflow platform
- Workflow platform subscribes to this command type via NServiceBus routing
- CommandData comes from CommandDefinition in FileRetrievalConfiguration (static metadata)

---

## Supporting DTOs

### ScheduleDefinitionDto

```csharp
public record ScheduleDefinitionDto
{
    public string CronExpression { get; init; } = default!;
    public string Timezone { get; init; } = default!;
    public string? Description { get; init; }
}
```

### EventDefinitionDto

```csharp
public record EventDefinitionDto
{
    public string EventType { get; init; } = default!;
    public Dictionary<string, object>? EventData { get; init; }
}
```

### CommandDefinitionDto

```csharp
public record CommandDefinitionDto
{
    public string CommandType { get; init; } = default!;
    public string TargetEndpoint { get; init; } = default!;
    public Dictionary<string, object>? CommandData { get; init; }
}
```

---

## NServiceBus Routing

### Endpoint Configuration

**FileRetrieval.Worker** (sends commands):
```csharp
endpointConfiguration.SendOnly(); // Or full endpoint if receives messages
var routing = endpointConfiguration.UseTransport<AzureServiceBusTransport>().Routing();
routing.RouteToEndpoint(typeof(ProcessDiscoveredFile), "WorkflowOrchestrator");
```

**FileRetrieval.API** (sends commands):
```csharp
var routing = endpointConfiguration.UseTransport<AzureServiceBusTransport>().Routing();
routing.RouteToEndpoint(typeof(CreateConfiguration), "FileRetrieval.Worker");
routing.RouteToEndpoint(typeof(UpdateConfiguration), "FileRetrieval.Worker");
routing.RouteToEndpoint(typeof(DeleteConfiguration), "FileRetrieval.Worker");
```

---

## Command Flow Examples

### Example 1: Scheduled File Check

```
Scheduler (every minute)
  ↓ checks configurations with due schedule
Send: ExecuteFileCheck command
  ↓ to FileRetrieval.Worker
ExecuteFileCheckHandler
  ↓ delegates to FileCheckService
FileCheckService.ExecuteCheck()
  ↓ calls protocol adapter
FtpProtocolAdapter.CheckForFiles()
  ↓ discovers 2 files
For each file:
  Create DiscoveredFile record (idempotency check)
  Send: ProcessDiscoveredFile command to WorkflowOrchestrator
  Publish: FileDiscovered event
  ↓
Publish: FileCheckCompleted event
```

### Example 2: Manual Configuration Creation

```
API: POST /api/configurations
  ↓ extracts clientId from JWT claims
  ↓ validates request body
Send: CreateConfiguration command
  ↓ to FileRetrieval.Worker
CreateConfigurationHandler
  ↓ delegates to ConfigurationService
ConfigurationService.CreateAsync()
  ↓ validates protocol settings
  ↓ validates token positions
  ↓ saves to Cosmos DB
Publish: ConfigurationCreated event
  ↓
API: Return 201 Created with configuration ID
```

---

## Summary

This contracts document defines:

✅ **5 command types**: ExecuteFileCheck, CreateConfiguration, UpdateConfiguration, DeleteConfiguration, ProcessDiscoveredFile  
✅ **Imperative naming**: All commands follow `Verb + Noun` convention  
✅ **Idempotency support**: All commands include IdempotencyKey and duplicate detection logic  
✅ **Multi-tenant isolation**: All commands include ClientId for security trimming  
✅ **Optimistic concurrency**: Update/Delete commands include ETag for safe concurrent updates  
✅ **Cross-platform integration**: ProcessDiscoveredFile command sent to workflow orchestration platform  
✅ **Validation rules**: Each command specifies required fields and validation logic  
✅ **Error handling**: Retry strategies and error scenarios documented  

Ready to proceed to **events.md** (event contracts).
