name: 'Build & Deploy Services (Reusable)'

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: string
      services:
        description: 'Services to deploy (comma-separated or "all")'
        required: true
        type: string

env:
  TERRAFORM_VERSION: '1.11.4'

jobs:
  # ==========================================================================
  # Parse Services List
  # ==========================================================================
  parse-services:
    name: 'Parse Services'
    runs-on: ubuntu-latest
    outputs:
      services_list: ${{ steps.parse.outputs.services_list }}
    
    steps:
      - name: Parse services input
        id: parse
        run: |
          INPUT="${{ inputs.services }}"
          
          if [ "$INPUT" == "all" ]; then
            SERVICES='["billing","customer","policy","fundstransfermgt","ratingandunderwriting"]'
          else
            SERVICES=$(echo "$INPUT" | jq -R -c 'split(",")')
          fi
          
          echo "services_list=$SERVICES" >> $GITHUB_OUTPUT
          echo "Services to deploy: $SERVICES"

  # ==========================================================================
  # Build and Push Docker Images
  # ==========================================================================
  build-and-push:
    name: 'Build & Push'
    needs: parse-services
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    permissions:
      id-token: write
      contents: read
    
    strategy:
      matrix:
        service: ${{ fromJson(needs.parse-services.outputs.services_list) }}

    outputs:
      image_tag: ${{ steps.tags.outputs.image_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set service paths
        id: paths
        run: |
          SERVICE="${{ matrix.service }}"
          echo "api_project=services/${SERVICE}/src/Api/Api.csproj" >> $GITHUB_OUTPUT
          echo "endpoint_project=services/${SERVICE}/src/Endpoint.In/Endpoint.In.csproj" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get ACR name
        id: acr
        run: |
          cd platform/infra/foundation
          terraform init -input=false
          ACR_NAME=$(terraform output -raw acr_name 2>/dev/null || echo "riskinsure${{ inputs.environment }}acr")
          ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server 2>/dev/null || echo "${ACR_NAME}.azurecr.io")
          echo "name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Login to ACR
        run: az acr login --name ${{ steps.acr.outputs.name }}

      - name: Set Docker tags
        id: tags
        run: |
          IMAGE_TAG="${{ github.sha }}"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build & Push API Image
        run: |
          docker build \
            -f platform/templates/Dockerfile.api.compose \
            --build-arg PROJECT_PATH=${{ steps.paths.outputs.api_project }} \
            -t ${{ steps.acr.outputs.login_server }}/${{ matrix.service }}-api:${{ steps.tags.outputs.image_tag }} \
            -t ${{ steps.acr.outputs.login_server }}/${{ matrix.service }}-api:latest \
            .
          
          docker push ${{ steps.acr.outputs.login_server }}/${{ matrix.service }}-api:${{ steps.tags.outputs.image_tag }}
          docker push ${{ steps.acr.outputs.login_server }}/${{ matrix.service }}-api:latest

      - name: Build & Push Endpoint Image
        run: |
          docker build \
            -f platform/templates/Dockerfile.endpoint.compose \
            --build-arg PROJECT_PATH=${{ steps.paths.outputs.endpoint_project }} \
            -t ${{ steps.acr.outputs.login_server }}/${{ matrix.service }}-endpoint:${{ steps.tags.outputs.image_tag }} \
            -t ${{ steps.acr.outputs.login_server }}/${{ matrix.service }}-endpoint:latest \
            .
          
          docker push ${{ steps.acr.outputs.login_server }}/${{ matrix.service }}-endpoint:${{ steps.tags.outputs.image_tag }}
          docker push ${{ steps.acr.outputs.login_server }}/${{ matrix.service }}-endpoint:latest

  # ==========================================================================
  # Deploy Container Apps
  # ==========================================================================
  deploy-apps:
    name: 'Deploy Container Apps'
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    permissions:
      id-token: write
      contents: read

    defaults:
      run:
        shell: bash
        working-directory: platform/infra/services

    outputs:
      billing_api_url: ${{ steps.outputs.outputs.billing_api_url }}
      # customer_api_url: ${{ steps.outputs.outputs.customer_api_url }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init -input=false
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Select tfvars file
        id: tfvars
        run: |
          ENV="${{ inputs.environment }}"
          if [ -f "${ENV}.tfvars" ]; then
            echo "file=${ENV}.tfvars" >> $GITHUB_OUTPUT
          else
            echo "file=" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Plan
        run: |
          if [ -n "${{ steps.tfvars.outputs.file }}" ]; then
            terraform plan \
              -var="image_tag=${{ needs.build-and-push.outputs.image_tag }}" \
              -var-file="${{ steps.tfvars.outputs.file }}" \
              -out=tfplan \
              -input=false
          else
            terraform plan \
              -var="environment=${{ inputs.environment }}" \
              -var="image_tag=${{ needs.build-and-push.outputs.image_tag }}" \
              -out=tfplan \
              -input=false
          fi
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        env:
          ARM_USE_OIDC: true
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Export Outputs
        id: outputs
        run: |
          echo "billing_api_url=$(terraform output -raw billing_api_url 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT
          echo "customer_api_url=$(terraform output -raw customer_api_url 2>/dev/null || echo 'N/A')" >> $GITHUB_OUTPUT

  # ==========================================================================
  # Health Checks
  # ==========================================================================
  health-check:
    name: 'Health Check'
    needs: deploy-apps
    runs-on: ubuntu-latest
    
    steps:
      - name: Wait for services
        run: sleep 60

      - name: Check Billing API
        continue-on-error: true
        run: |
          URL="${{ needs.deploy-apps.outputs.billing_api_url }}"
          if [ "$URL" != "N/A" ]; then
            curl -f -s "${URL}/health" && echo "✅ Billing API healthy" || echo "⚠️ Billing API check failed"
          fi

      - name: Check Customer API
        continue-on-error: true
        run: |
          URL="${{ needs.deploy-apps.outputs.customer_api_url }}"
          if [ "$URL" != "N/A" ]; then
            curl -f -s "${URL}/health" && echo "✅ Customer API healthy" || echo "⚠️ Customer API check failed"
          fi